<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-K7WDT4BQRY"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-K7WDT4BQRY');
    </script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />

  <title>Kevlar</title>

  <link rel="stylesheet" href="https://thewagner.net/theme/css/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

  <link href="https://thewagner.net/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="The Wagner Atom Feed" />


</head>

<body>
  <nav class="navbar" role="navigation">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://thewagner.net/">The Wagner       </a>

      <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div class="navbar-menu" id="navMenu">
      <div class="navbar-start">
        <!-- Menu items -->
        <!-- Pages -->
        <!-- Categories -->
      </div>
      <div class="navbar-end">
          <a class="navbar-item" href="https://github.com/wagdav">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
        <a class="navbar-item" href="https://thewagner.net/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
        </a>
      </div>
    </div>
  </nav>

<section class="section">
  <div class="container is-max-desktop">
    <h1 class="title">
      <a href="https://thewagner.net/blog/2020/10/18/kevlar/" rel="bookmark"
         title="Permalink to Kevlar">Kevlar</a></h1>

    <h2 class="subtitle">
<time class="published" datetime="2020-10-18T00:00:00+02:00">October 18, 2020</time>
<span class="vcard author">
    <a class="url fn" href="https://thewagner.net/author/david-wagner.html">David Wagner</a>
</span>
    </h2>

    <div class="content" style="hyphens:auto">
      <p>Previously, I distilled the <a href="https://thewagner.net/blog/2020/01/07/the-essence-of-a-cicd-pipeline/">essence of a software delivery
pipeline</a> and argued
that a transformation step that builds or tests a piece of code can be viewed
as a function.  Functions compose according to well-defined mathematical rules
and they are a suitable model for defining arbitrary pipelines.  Instead of
talking about build tasks, jobs, stages and workflows, the build pipeline could
be a function that takes the source code as argument and returns build&nbsp;artifacts.</p>
<p>In this article I describe, Kevlar, an experimental build automation tool that
tries to build on these&nbsp;concepts.</p>
<h1>Programming in <span class="caps">YAML</span></h1>
<p>For almost two years I was part of a team building a build automation system
for <a href="https://pix4d.com">Pix4D</a>, a medium-sized organization&nbsp;with:</p>
<ul>
<li>Few dozen&nbsp;developers</li>
<li>Handful of&nbsp;projects</li>
<li>Couple of programming&nbsp;languages</li>
</ul>
<p>We wanted a system to build our software products on all the major desktop
and mobile platforms.  A few years back when the project started the scene of
managed build automation tools was less exiting than today: Travis <span class="caps">CI</span> was a a
major player, GitLab was on the rise, GitHub Actions and CircleCI didn&#8217;t&nbsp;exist.</p>
<p>For various reasons we ruled out the available hosted options and we deployed
<a href="https://concourse-ci.org/">Concourse <span class="caps">CI</span></a> in our data centers.  Concourse
served us well: today Pix4D&#8217;s continuous integration system builds more
libraries and products than ever.  Concourse uses <span class="caps">YAML</span> for describing its
pipelines which model the software delivery process.  And <span class="caps">YAML</span> started to
sprout&nbsp;everywhere.</p>
<p>Although <span class="caps">YAML</span> is used to configure virtually all build automation systems its
limitations become apparent when you write a pipeline for any reasonably
complex software project.  Using only numbers, strings, lists and associative
arrays pipeline definitions are verbose and&nbsp;repetitive.</p>
<p>To allow for reusing pipeline code build automation systems introduced ad-hoc
concepts and workarounds.  Some examples&nbsp;are:</p>
<ul>
<li><a href="https://concourse-ci.org/config-basics.html#yaml-tips-and-tricks"><span class="caps">YAML</span>&nbsp;anchors</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/templates">Templates</a></li>
<li><a href="https://circleci.com/docs/2.0/pipeline-variables/">Pipeline&nbsp;Variables</a></li>
<li><a href="https://github.com/vito/oci-build-task">Reusable build&nbsp;tasks</a></li>
<li><a href="https://circleci.com/orbs/">Orbs</a></li>
</ul>
<p>Many systems also provide control flow operators such as conditionals, loops
and other <a href="https://circleci.com/blog/circleci-matrix-jobs/">special constructs</a>
to express, for example, matrix builds.  Ultimately the pipeline configuration
becomes an <a href="https://thewagner.net/blog/2019/12/20/functions-in-disguise/">implicitly functional programming
language</a> using <span class="caps">YAML</span>&#8217;s&nbsp;syntax.</p>
<p>In programming we reduce repetition using methods, functions and procedures.
We organize our code in modules and packages for sharing and reuse.  Let&#8217;s try
to use these concepts to express software delivery&nbsp;pipelines.</p>
<h1>Enter&nbsp;Kevlar</h1>
<p>I found programming in <span class="caps">YAML</span> frustrating and I wanted to explore how a build
pipeline would look like in a general-purpose programming language.  <a href="https://github.com/wagdav/kevlar">Project
Kevlar</a> was&nbsp;born.</p>
<p>In Kevlar you express the build pipelines using Haskell functions. A step that
<a href="https://github.com/wagdav/kevlar/blob/master/.kevlar/config.hs">builds Kevlar itself</a> looks like&nbsp;this:</p>
<div class="highlight"><pre><span></span><code><span class="nf">build</span><span class="w"> </span><span class="n">repo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="n">src</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="n">repo</span>
<span class="w">  </span><span class="n">img</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Kaniko</span><span class="o">.</span><span class="n">build</span>
<span class="w">    </span><span class="s">&quot;kevlar-builder&quot;</span>
<span class="w">    </span><span class="s">&quot;docker/kevlar-builder&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="kt">Need</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">]</span>
<span class="w">  </span><span class="n">shell</span>
<span class="w">    </span><span class="p">[</span><span class="s">&quot;./ci/build.sh&quot;</span><span class="p">]</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="kt">Need</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="kt">Image</span><span class="w"> </span><span class="n">img</span><span class="p">,</span>
<span class="w">    </span><span class="p">]</span>
</code></pre></div>

<p>This function takes the source repository as a parameter and describes the
following&nbsp;actions:</p>
<ul>
<li>Clone the source&nbsp;repository.</li>
<li>Run <a href="https://github.com/GoogleContainerTools/kaniko">Kaniko</a> to build a
  container image described in a Dockerfile of the source&nbsp;repository.</li>
<li>Start a container from the build image and execute the build&nbsp;script.</li>
</ul>
<p>The <code>Need</code> argument of the functions express data dependencies explicitly.  We
need the cloned repository to build the Docker image because the <code>Dockerfile</code>
is found there.  Similarly, because the build script is running in a container
it needs both the source code checked out and the container&#8217;s image&nbsp;built.</p>
<p>The syntax may be unusual, but it&#8217;s just regular Haskell code.  This could have
been easily written in <span class="caps">YAML</span> with equal clarity, so why bother with Haskell?
The advantages of using real programming language constructs appear when we
build more complicated workflows.  As pipelines grow we can factor out common
into helper functions or shared modules and&nbsp;packages.</p>
<p>Let&#8217;s continue building Kevlar&#8217;s own pipeline by adding a publish&nbsp;step:</p>
<div class="highlight"><pre><span></span><code><span class="nf">publish</span><span class="w"> </span><span class="n">repo</span><span class="w"> </span><span class="n">binary</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="n">src</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="n">repo</span>
<span class="w">  </span><span class="n">img</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Kaniko</span><span class="o">.</span><span class="n">build</span>
<span class="w">    </span><span class="s">&quot;kevlar-publish&quot;</span>
<span class="w">    </span><span class="s">&quot;docker/kevlar-publish&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="kt">Need</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">]</span>
<span class="w">  </span><span class="n">shell</span>
<span class="w">    </span><span class="p">[</span><span class="s">&quot;./ci/publish.sh&quot;</span><span class="p">]</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="kt">Need</span><span class="w"> </span><span class="n">binary</span><span class="w"> </span><span class="s">&quot;build&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="kt">Need</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="kt">Image</span><span class="w"> </span><span class="n">img</span><span class="p">,</span>
<span class="w">      </span><span class="kt">Secret</span><span class="w"> </span><span class="s">&quot;GITHUB_ACCESS_TOKEN&quot;</span>
<span class="w">    </span><span class="p">]</span>
</code></pre></div>

<p>The <code>publish</code> function takes the address of the source repository and the build
binary. The steps are similar to that of the <code>build</code> function:</p>
<ul>
<li>Clone the source&nbsp;repository.</li>
<li>Build a Docker image with the tools required for releasing the binary&nbsp;artifacts.</li>
<li>Start a container from the built image and execute the publish&nbsp;script.</li>
</ul>
<p>With the <code>build</code> and <code>publish</code> functions we can succinctly define Kevlar&#8217;s
build-and-release&nbsp;pipeline:</p>
<div class="highlight"><pre><span></span><code><span class="nf">buildAndPublish</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">build</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">publish</span><span class="w"> </span><span class="n">src</span>
</code></pre></div>

<p>This function, which composes <code>build</code> and <code>publish</code> using the monadic bind
operator, actually works it does what you&#8217;d expect: the pipeline builds and
publishes the built binaries running both steps in dedicated Docker&nbsp;containers.</p>
<p>We may refer to the functions <code>build</code> and <code>publish</code> as &#8220;steps&#8221; and the function
<code>buildAndPublish</code> as the final &#8220;pipeline&#8221;.  In Kevlar they are all represented
as functions returning a <code>Task</code> value.</p>
<p>The function <code>buildAndPublish</code> defines the following graph of&nbsp;dependencies:</p>
<div class="highlight"><pre><span></span><code>           ↗ build image  → compile ↘
clone repo                            publish
           ↘        build image     ↗
</code></pre></div>

<p>This figure reveals interesting optimization&nbsp;opportunities:</p>
<ul>
<li>We could run the image building steps in parallel because they don&#8217;t use each
  other&#8217;s&nbsp;output.</li>
<li>We could avoid cloning the repository twice and reuse the repository&#8217;s local
  copy in downstream&nbsp;steps.</li>
</ul>
<p>The next sections expand on these ideas in&nbsp;detail.</p>
<h2>Automatic&nbsp;parallelism</h2>
<p>Instead of naively executing each steps as they appear in the source code,
Kevlar uses as much parallelism as possible.  The user defines data
dependencies using the <code>Need</code> parameter and <a href="https://thewagner.net/blog/2020/02/29/parallel-mindset/">parallelism is
automatic</a>.  This idea is not
new: for example build systems like make and ninja track dependencies among
build steps and schedule as many of them as they can on the available&nbsp;processors.</p>
<p>Initially I built Kevlar on top of <a href="https://github.com/ndmitchell/shake">Shake</a>, a library for creating build
systems.  Shake is a well-designed and performant library but it was a poor fit
for Kevlar.  Shake takes the source code and builds your program&#8217;s binary as
fast as possible.  Build rules and dependencies between tasks rely on file
names and file patterns.  I needed a library to express general data
dependencies in the pipeline code without using the file&nbsp;system.</p>
<p>I switched Kevlar to use <a href="https://github.com/facebook/Haxl">Haxl</a> to make parallelism automatic.  Haxl
relies on some algebraic properties of the program to identify data
dependencies between tasks and schedules many independent tasks concurrently.
The <a href="https://www.youtube.com/watch?v=sT6VJkkhy0o">magic of Haxl</a> is contained within its own codebase and  I only
had to implement a <a href="https://github.com/wagdav/kevlar/blob/master/src/Kevlar/LocalExecutor/DataSource.hs">custom data source</a>.  Even better, the
user, in this case the pipeline author, doesn&#8217;t need to be aware of any of this
and the pipeline remains a regular Haskell&nbsp;function.</p>
<p>Today&#8217;s popular build automation systems require the user to explicitly choose
between sequential or parallel execution when designing the pipeline.  Concepts
like tasks, steps, jobs are introduced with an emphasis of execution order
instead of <a href="https://thewagner.net/blog/2020/01/07/the-essence-of-a-cicd-pipeline/">capturing the
meaning</a> of the
transformation steps in the software delivery&nbsp;process.</p>
<p>In Kevlar the user is only concerned with data dependencies.  The system makes
sure that the pipeline&#8217;s task run in the right order as fast as&nbsp;possible.</p>
<h2>Incremental&nbsp;work</h2>
<p>Avoiding extra work is crucial for good performance.  The output of a given
task should be reused as the pipeline executes: the output might be available
from earlier steps or from earlier&nbsp;executions.</p>
<p>Reusing a result is desired if the pipeline fans out: we compute the result
once and copy it to the downstream tasks.  We&#8217;ve seen an example of this in the
previous section where the repository&#8217;s local copy was passed to start building
the two container images&nbsp;independently.</p>
<p>Reusing results from earlier executions is harder.  Tasks may return many kinds
of outputs: single files, directories, container images.  These all need to be
persisted somewhere to be reused during the next pipeline execution.  I
couldn&#8217;t find a satisfactory solution to this in&nbsp;Kevlar.</p>
<h1>Summary</h1>
<p>Frustrated by the verbose <span class="caps">YAML</span> configuration used by popular build automation
tools I wrote Kevlar, an experimental system, where the pipeline configuration
is expressed in a functional programming&nbsp;language.</p>
<p>Pipelines are functions which define data dependencies and not execution order.
With some help from great libraries parallelism is automatic and duplicate work
is&nbsp;avoided.</p>
<p>Working on Kevlar made me appreciate even more the power of pure functions:
values, functions and their combinations are powerful modeling tools.  When
thinking functionally you ask what things <em>are</em> instead of what they <em>do</em> and
this leads to interesting discoveries and simple, solid&nbsp;designs.</p>
<p>I also realized that I&#8217;m rediscovering <a href="https://thewagner.net/blog/2020/04/30/exploring-nix/">the basic principles of
Nix</a> and Nix is so much better
than Kevlar ever wanted to be.  If the ideas in this article resonate with you
I recommend to try building your <a href="https://thewagner.net/blog/2020/07/03/deploying-thewagnernet/">next software delivery pipeline with
Nix</a>.</p>
<h1>Acknowledgment</h1>
<p>I dedicate this post to the memory of my friend and colleague Salah Missri who
tragically passed away earlier this year.  Salah was the biggest fan of Kevlar.
He patiently listened to me ranting about continuous integration systems and
encouraged me keep working on Kevlar until it reaches world&nbsp;domination.</p>
    </div><!-- /.entry-content -->
  </div>
</section>

  <section id="extras" class="body">
  </section><!-- /#extras -->

    <footer class="footer">
      <div class="content has-text-centered">
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
        <p>
          <small>Revision: <a href="https://github.com/wagdav/thewagner.net/commit/4bf3ff1">4bf3ff</a></small>
        </p>
      </div>
    </footer><!-- /#contentinfo -->
</body>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Get all "navbar-burger" elements
    const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

    // Add a click event on each of them
    $navbarBurgers.forEach(el => {
      el.addEventListener('click', () => {
        // Get the target from the "data-target" attribute
        const target = el.dataset.target;
        const $target = document.getElementById(target);

        // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
        el.classList.toggle('is-active');
        $target.classList.toggle('is-active');
      });
    });
  });
</script>
</html>