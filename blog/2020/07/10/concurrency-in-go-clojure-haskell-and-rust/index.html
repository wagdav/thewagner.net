<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-K7WDT4BQRY"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-K7WDT4BQRY');
    </script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />

  <title>Concurrency in Go, Clojure, Haskell and Rust</title>

  <link rel="stylesheet" href="https://thewagner.net/theme/css/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

  <link href="https://thewagner.net/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="The Wagner Atom Feed" />


</head>

<body>
  <nav class="navbar" role="navigation">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://thewagner.net/">The Wagner       </a>

      <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div class="navbar-menu" id="navMenu">
      <div class="navbar-start">
        <!-- Menu items -->
        <!-- Pages -->
        <!-- Categories -->
      </div>
      <div class="navbar-end">
          <a class="navbar-item" href="https://github.com/wagdav">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
        <a class="navbar-item" href="https://thewagner.net/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
        </a>
      </div>
    </div>
  </nav>

<section class="section">
  <div class="container is-max-desktop">
    <h1 class="title">
      <a href="https://thewagner.net/blog/2020/07/10/concurrency-in-go-clojure-haskell-and-rust/" rel="bookmark"
         title="Permalink to Concurrency in Go, Clojure, Haskell and Rust">Concurrency in Go, Clojure, Haskell and&nbsp;Rust</a></h1>

    <h2 class="subtitle">
<time class="published" datetime="2020-07-10T00:00:00+02:00">July 10, 2020</time>
<span class="vcard author">
    <a class="url fn" href="https://thewagner.net/author/david-wagner.html">David Wagner</a>
</span>
    </h2>

    <div class="content" style="hyphens:auto">
      <p>In the past I wrote <a href="https://thewagner.net/blog/2018/02/26/concurrency-patterns/">two</a> <a href="/blog/2019/07/15/concurrency-without-magic/">articles</a> where I
explored concurrency in Haskell using some examples from the talk <a href="https://talks.golang.org/2012/concurrency.slide">Go
Concurrency Patterns</a> by Rob&nbsp;Pike.</p>
<p>The examples are different implementations of a simulated search engine which
receives a search query and returns web, image and video results.  The first
version sends the search queries sequentially.  Then, the program is gradually
improved to become concurrent and better&nbsp;performing.</p>
<p>Earlier I presented <a href="https://thewagner.net/blog/2018/02/26/concurrency-patterns/">each step</a> in detail.  Here I will only
show the final form of the fake search function in four different programming
languages: Go, Clojure, Haskell and&nbsp;Rust.</p>
<h1>Go</h1>
<p><a href="https://talks.golang.org/2012/concurrency.slide">Rob Pike&#8217;s version</a> of the search function executes the three kinds
of search queries concurrently and sends the search requests to replicated
back-end servers to reduce tail&nbsp;latency.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// https://talks.golang.org/2012/concurrency.slide#50</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">search</span><span class="p">(</span><span class="nx">query</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">results</span><span class="w"> </span><span class="p">[]</span><span class="nx">Result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">Result</span><span class="p">)</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">First</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span><span class="w"> </span><span class="nx">Web1</span><span class="p">,</span><span class="w"> </span><span class="nx">Web2</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">First</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span><span class="w"> </span><span class="nx">Image1</span><span class="p">,</span><span class="w"> </span><span class="nx">Image2</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">First</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span><span class="w"> </span><span class="nx">Video1</span><span class="p">,</span><span class="w"> </span><span class="nx">Video2</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="nx">timeout</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="mi">80</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">select</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
<span class="w">            </span><span class="nx">results</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">results</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">timeout</span><span class="p">:</span>
<span class="w">            </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;timed out&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span>
<span class="p">}</span>
</code></pre></div>

<p>The implementation shows Go&#8217;s concurrency primitives: goroutines, channels, and
the select statement.  The Go runtime manages the goroutines which are
lightweight threads of execution.  Goroutines communicate via channels.  The
<code>switch</code> statement allows merging values originating from multiple channels.
These constructs are all built into the language, no external library is&nbsp;required.</p>
<h1>Clojure</h1>
<p>I was surprised when Rich Hickey mentioned the fake search example in his
presentation on <a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Clojure core async</a>.  I copied here the code
from the slides for&nbsp;reference:</p>
<div class="highlight"><pre><span></span><code><span class="c1">;; https://www.youtube.com/watch?v=drmNlZVkUeE?t=2458</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">search</span><span class="w"> </span><span class="p">[</span><span class="nv">query</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">)</span>
<span class="w">        </span><span class="nv">t</span><span class="w"> </span><span class="p">(</span><span class="nf">timeout</span><span class="w"> </span><span class="mi">80</span><span class="p">)]</span>
<span class="w">    </span><span class="p">(</span><span class="nf">go</span><span class="w"> </span><span class="p">(</span><span class="nf">&gt;!</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!</span><span class="w"> </span><span class="p">(</span><span class="nf">fastest</span><span class="w"> </span><span class="nv">query</span><span class="w"> </span><span class="nv">web1</span><span class="w"> </span><span class="nv">web2</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">go</span><span class="w"> </span><span class="p">(</span><span class="nf">&gt;!</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!</span><span class="w"> </span><span class="p">(</span><span class="nf">fastest</span><span class="w"> </span><span class="nv">query</span><span class="w"> </span><span class="nv">image1</span><span class="w"> </span><span class="nv">image2</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">go</span><span class="w"> </span><span class="p">(</span><span class="nf">&gt;!</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!</span><span class="w"> </span><span class="p">(</span><span class="nf">fastest</span><span class="w"> </span><span class="nv">query</span><span class="w"> </span><span class="nv">video1</span><span class="w"> </span><span class="nv">video2</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">go</span><span class="w"> </span><span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="mi">0</span>
<span class="w">               </span><span class="nv">ret</span><span class="w"> </span><span class="p">[]]</span>
<span class="w">          </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">i</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">            </span><span class="nv">ret</span>
<span class="w">            </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nb">conj </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nf">alt!</span><span class="w"> </span><span class="p">[</span><span class="nv">c</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="p">([</span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="nv">v</span><span class="p">)))))))))</span>
</code></pre></div>

<p>Clojure&#8217;s async library uses the same primitives as Go: the syntax is <span class="caps">LISP</span>, but
the structure of the program is identical to that of the Go version.  Watch
<a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Rich Hickey&#8217;s presentation</a> if you&#8217;re interested how this
works on the <span class="caps">JVM</span> and in a web browser using&nbsp;ClojureScript.</p>
<h1>Haskell</h1>
<p>My first implementation of the simulated search engine was in
<a href="https://thewagner.net/blog/2018/02/26/concurrency-patterns/">Haskell</a>:</p>
<div class="highlight"><pre><span></span><code><span class="nf">search30</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">SearchQuery</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">search30</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">    </span><span class="n">req</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="n">maxDelay</span><span class="w"> </span><span class="o">$</span>
<span class="w">        </span><span class="n">mapConcurrently</span><span class="w"> </span><span class="p">(</span><span class="n">fastest</span><span class="w"> </span><span class="n">query</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="kt">Web</span><span class="p">,</span><span class="w"> </span><span class="kt">Image</span><span class="p">,</span><span class="w"> </span><span class="kt">Video</span><span class="p">]</span>
<span class="w">    </span><span class="n">printResults</span><span class="w"> </span><span class="n">req</span>
</code></pre></div>

<p>This is my favorite version of this exercise because it&#8217;s succint and
expressive.  We don&#8217;t see the primitives we saw in the Go and Clojure version,
but an expression stating that some operations are expected to run
concurrently.  Writing this high-level code is possible because the threads are
managed by the Haskell run-time system and I&#8217;m using the <a href="https://hackage.haskell.org/package/async-2.1.0/docs/Control-Concurrent-Async.html">async</a>
library which exposes a powerful, composable <span class="caps">API</span>.</p>
<h1>Rust</h1>
<p>My latest addition to this collection is <a href="https://github.com/wagdav/rust-concurrency-patterns">written in Rust</a>, a
language I&#8217;ve been learning for the last couple of&nbsp;weeks:</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">search30</span><span class="p">(</span><span class="n">query</span>: <span class="kp">&amp;</span><span class="nc">SearchQuery</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">SearchResult</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">timeout</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">80</span><span class="p">),</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">tokio</span>::<span class="n">join</span><span class="o">!</span><span class="p">(</span>
<span class="w">            </span><span class="n">fastest</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">SearchKind</span>::<span class="n">Web</span><span class="p">),</span>
<span class="w">            </span><span class="n">fastest</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">SearchKind</span>::<span class="n">Image</span><span class="p">),</span>
<span class="w">            </span><span class="n">fastest</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">SearchKind</span>::<span class="n">Video</span><span class="p">),</span>
<span class="w">        </span><span class="p">)</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="k">await</span>
<span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">web</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">video</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">SearchResult</span>::<span class="n">new</span><span class="p">(</span><span class="n">web</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">video</span><span class="p">))</span>
<span class="w">    </span><span class="p">.</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">SearchResult</span>::<span class="n">timeout</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div>

<p>This code looks similar to the Haskell version because we don&#8217;t see channels
and explicit thread management here either.  The Rust language defines the
<code>async/await</code> syntax and the related interfaces but it delegates the concrete
execution strategy to external libraries.  In this example I chose the
<a href="https://tokio.rs/">Tokio</a> library which is a mature asynchronous run-time library, but
in the future I&#8217;d like to explore other libraries too and learn more about how
they&nbsp;work.</p>
<p>Asyncronous programming in Rust is a <a href="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html">recent addition</a> to the
language.  If you&#8217;re interested how this feature was designed I recommend
watching <a href="https://www.youtube.com/watch?v=lJ3NC-R3gSI">Steve Klabnik&#8217;s talk</a>.</p>
<h1>Summary</h1>
<p>Modern languages provide ways of expressing concurrent operations using
built-in language primitives or external libraries.  Writing a simulated search
engine is a great exercise to learn about concurrency because it requires to
think about thread creation, thread cancellation and merging results from
multiple&nbsp;threads.</p>
    </div><!-- /.entry-content -->
  </div>
</section>

  <section id="extras" class="body">
  </section><!-- /#extras -->

    <footer class="footer">
      <div class="content has-text-centered">
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
        <p>
          <small>Revision: <a href="https://github.com/wagdav/thewagner.net/commit/3d24187">3d2418</a></small>
        </p>
      </div>
    </footer><!-- /#contentinfo -->
</body>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Get all "navbar-burger" elements
    const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

    // Add a click event on each of them
    $navbarBurgers.forEach(el => {
      el.addEventListener('click', () => {
        // Get the target from the "data-target" attribute
        const target = el.dataset.target;
        const $target = document.getElementById(target);

        // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
        el.classList.toggle('is-active');
        $target.classList.toggle('is-active');
      });
    });
  });
</script>
</html>