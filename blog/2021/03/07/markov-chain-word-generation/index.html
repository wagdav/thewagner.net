<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />

  <title>Markov-chain word generation</title>

  <link rel="stylesheet" href="https://thewagner.net/theme/css/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

  <link href="https://thewagner.net/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="The Wagner Atom Feed" />


</head>

<body>
  <nav class="navbar" role="navigation">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://thewagner.net/">The Wagner       </a>

      <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div class="navbar-menu" id="navMenu">
      <div class="navbar-start">
        <!-- Menu items -->
        <!-- Pages -->
        <!-- Categories -->
      </div>
      <div class="navbar-end">
          <a class="navbar-item" href="https://github.com/wagdav">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
        <a class="navbar-item" href="https://thewagner.net/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
        </a>
      </div>
    </div>
  </nav>

<section class="section">
  <div class="container is-max-desktop">
    <h1 class="title">
      <a href="https://thewagner.net/blog/2021/03/07/markov-chain-word-generation/" rel="bookmark"
         title="Permalink to Markov-chain word generation">Markov-chain word generation</a></h1>

    <h2 class="subtitle">
<time class="published" datetime="2021-03-07T00:00:00+01:00">March 07, 2021</time>
<span class="vcard author">
    <a class="url fn" href="https://thewagner.net/author/david-wagner.html">David Wagner</a>
</span>
    </h2>

    <div class="content" style="hyphens:auto">
      <p>Recently I reread some chapters of the book <a href="https://www.cs.princeton.edu/~bwk/tpop.webpage/">The Practice of Programming by
Brian Kernighan and Rob Pike</a>.  In Chapter 3 on <em>Design and
Implementation</em> the authors present several implementations of a random text
generator to compare how various languages' idioms express the same idea.</p>
<p>I wrote my version in Rust which I present in this article with some example
text I generated using various sources.</p>
<h1>Random text</h1>
<p>The goal is to write a program that generates random English text that reads
well.  The program takes a large body of text as input to construct a
statistical model of the language as used in that text.  Then the program
generates random text that has similar statistics to the original.</p>
<p>Here's an example generated sentence, given the words of all articles of this
blog:</p>
<blockquote>
<p>In this article resonate with you I recommend to watch the original talk on
YouTube with meticulously prepared slides, what we see similar configuration
blocks everywhere.</p>
</blockquote>
<p>This is obviously nonsense, but the program may generate some funny phrases,
especially if the input is long and varied.</p>
<p>The program uses a <a href="https://en.wikipedia.org/wiki/Markov_chain">Markov-chain</a> algorithm to generate text.  The
words of the input text are arranged in a data structure that records which
two-word combinations are followed by which words.</p>
<p>For example, let's assume that in the input text the words <em>In this</em> are
followed by one of the following words: <em>example, post, workshop, specific,
representation</em>.  Starting from <em>In this</em>, we generate the next word by
choosing randomly from these candidates.  Let's say we pick <em>specific</em>.  Then,
in the next iteration we repeat the same procedure for the words <em>this
specific</em>.  We can continue generating new words until we have candidate words
to pick from.</p>
<h1>Rust implementation</h1>
<p>I wrote my version of the word generator program in Rust.  This code snippet
shows its basic usage:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ChainBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">         </span><span class="c1">// ①</span>
<span class="k">for</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">words</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">builder</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word</span><span class="p">);</span><span class="w">                         </span><span class="c1">// ②</span>
<span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="n">chain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">build</span><span class="p">();</span><span class="w">                    </span><span class="c1">// ③</span>
<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">chain</span><span class="p">.</span><span class="n">generate</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span><span class="n">join</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">));</span><span class="w">  </span><span class="c1">// ④</span>
</code></pre></div>

<ol>
<li>Create a <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">ChainBuilder</a>.  The chain will use two-word prefixes
   to detemine the next word.</li>
<li>Add words from the input text and store them in a hash-map internally.</li>
<li>Finish building and create the actual <code>Chain</code>.</li>
<li>Use the <code>Chain</code> to generate 100 words and print them as a sentence.</li>
</ol>
<p>The whole implementation is 129 lines long and it's available on
<a href="https://github.com/wagdav/markov">GitHub</a>.  It's a complete command-line application with help texts
and proper argument parsing.  The used algorithm and data structures are
identical to those described in <a href="https://www.cs.princeton.edu/~bwk/tpop.webpage/">the book</a>.  You can also find the C,
C++, Java, Perl and AWK versions written by Kernighan and Pike
<a href="https://www.cs.princeton.edu/~bwk/tpop.webpage/code.html">here</a>.</p>
<h1>Examples</h1>
<p>Let's see some generated texts based on different data sets.  The prefix length
is always two.  The code gives a random text at each execution and I ran the
program a few times until I obtained a variant which I found funny or
interesting.  Often I stripped the unfinished, partial sentences from the end
of the text.</p>
<h2>Book of Psalms</h2>
<p>Kernighan and Pike use the <a href="https://www.gutenberg.org/ebooks/8019">Book of Psalms from the King James Bible</a>
as a test dataset because it  has many repeated phrases (<em>Blessed is the...</em>)
which provides chains with large suffix sets.  I started to test my program
with this data set.  Here's one example:</p>
<blockquote>
<p>Blessed is the lord. Praise the lord, at the blast of the enemy: thou hast
maintained my right hand is full of water: thou preparest them corn, when
thou hast known my soul had almost dwelt in silence.</p>
</blockquote>
<p>Indeed, the characteristics of the input dataset are recognizable in each
random output,  the text reads like prayer using archaic English words.</p>
<h2>Technobabble</h2>
<p><a href="https://science.ksc.nasa.gov/shuttle/missions/51-l/docs/rogers-commission/Appendix-F.txt">Richard Feynman's observations on the reliability of the Shuttle</a> is
a fantastic read on it own.  The 5000 word long eloquent, technical text is an
excellent source for technobabble generation.</p>
<blockquote>
<p>It appears that there are three engines, but some accidents would possibly be
contained, and only three in the second 125,000 seconds. Naturally, one can
never be sure that all is safe by inspecting all blades for cracks. If they
are found, replace them, and if none are found in the list above). These we
discuss below. (Engineers at Rocketdyne, were made.</p>
</blockquote>
<p>In this example we can see that the implementation has no notion of
punctuation: unmatched parentheses appear at random places because they are
considered to be part of the word.</p>
<p>Here's another one:</p>
<blockquote>
<p>It appears that there are enormous differences of opinion as to the Space
Shuttle Main Engine. Cracks were found after 4,200 seconds, although usually
these longer runs showed cracks. To follow this story further we shall have to
realize that the rule seems to have been solved.</p>
</blockquote>
<h2>Blog corpus</h2>
<p>Finally I tried to generate a random blog post using the articles I've written
here.</p>
<p>I used <a href="https://pandoc.org">Pandoc</a> to convert the markdown files I've written
to plain text:</p>
<div class="highlight"><pre><span></span><code>pandoc<span class="w">  </span>*.markdown<span class="w"> </span>--from<span class="w"> </span>markdown<span class="w"> </span>--to<span class="w"> </span>plain
</code></pre></div>

<p>This yields about 20 thousand words of text, some of which appear in equations,
enumerations and code blocks.  I wrote a function to ignore almost everything
but the actual text.   Here are two examples which show that the program is not
quite ready to replace me in writing new articles:</p>
<blockquote>
<p>In this representation we can assume that we exploit that IO is a simple
function. Its imaginary type signature is: This reads: the configuration blocks
we implicitly created a simple function. Its imaginary type signature is: This
reads: the configuration code on GitHub.</p>
<p>In this niche domain the utility of functions is well studied and understood.
Ideas from purely functional programming language using YAML’s syntax. In
programming we use fmap to lift our pure project function to be Python, but it
was served from. We now are ready to define components, component configuration
and component relationships.</p>
</blockquote>
<p>In these outputs I can recognize full sentences of my previous articles which
shows that the blog corpus is not large enough for automatic blogging.</p>
<h1>Summary</h1>
<p>Using a Markov-chain to generate random text in a given "style" is a fun
programming exercise.  The problem can be solved in a few dozen lines of code,
but it teaches a lot about algorithms and design in general.</p>
    </div><!-- /.entry-content -->
  </div>
</section>

  <section id="extras" class="body">
  </section><!-- /#extras -->

    <footer class="footer">
      <div class="content has-text-centered">
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" width="88" height="31"/></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
        <p>
          <small>Revision: <a href="https://github.com/wagdav/thewagner.net/commit/b7552da">b7552d</a></small>
        </p>
      </div>
    </footer><!-- /#contentinfo -->
</body>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Get all "navbar-burger" elements
    const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

    // Add a click event on each of them
    $navbarBurgers.forEach(el => {
      el.addEventListener('click', () => {
        // Get the target from the "data-target" attribute
        const target = el.dataset.target;
        const $target = document.getElementById(target);

        // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
        el.classList.toggle('is-active');
        $target.classList.toggle('is-active');
      });
    });
  });
</script>
</html>